import {describe, expect, test} from '@jest/globals';
import {parseModule} from "../../src/parser";
import  * as types from "../../src/types";
import  {WASMSectionID} from "../../src/types";
import {decodeSignedLeb128 as lebToInt} from "../../src/leb128ToInt"
import * as bp from "../../src/bodyParser";
import * as descParser from "../../src/helperParser";
import fs from 'fs';
//npm install --save-dev ts-jest
//npm install @types/jest
//npx ts-jest config:init
//npx jest

// const input = new Uint8Array(fs.readFileSync('../tests/arrays.wasm'));
// console.log(JSON.stringify(parseModule(output), null, 1));

describe("parseImport", () => {
    test("parseImport section from arrays.wasm", () => { 
        const importTest = new Uint8Array([0x01, 0x07, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x73, 0x0B, 0x72, 0x65, 0x64, 0x75, 0x63, 0x65, 0x5F, 0x66, 0x75, 0x6E, 0x63, 0x00, 0x02]);
        let result = bp.parseImport(importTest, 0);
        expect(result).toEqual(
            [
                {
                  module: [ 7, 'imports' ],
                  name: [ 11, 'reduce_func' ],
                  description: 2
                }
              ]
        )

    })
})
describe("parseFunction", () =>{
    test("parseFunction section from arrays.wasm", ()=>{
        const functionTest = new Uint8Array([0x0A, 0x00, 0x00, 0x02, 0x03, 0x02, 0x04, 0x00, 0x04, 0x02, 0x02]);
        let result = bp.parseFunction(functionTest, 0);
        expect(result).toEqual(
            [0,0,2,3,2,4,0,4,2,2]
        )
    })
})
describe("parseTable", () =>{

})

describe("parseMemory", ()=>{
    //limits array
    test("parseMemory section from arrays.wasm", () => {
        const memory = new Uint8Array([0x01, 0x00, 0x01]);
        let result = bp.parseMemory(memory, 0);
        expect(result).toEqual(
           [{
            flag: 0,
            min: 1
           }]
        )
    })
})
describe("descParser.parseLimits", () => {
    test("parselimit flag 1", () => {
        const limit = new Uint8Array([0x01, 0x01, 0x02]);
        let result = descParser.parseLimits(limit, 0);
        expect(result).toEqual(
           [{
            flag: 1,
            min: 1,
            max: 2
           }, 3]
        )
        
    })
    test("parselimit flag 0", () => {
        const limit = new Uint8Array([0x00, 0x04]);
        let result = descParser.parseLimits(limit, 0);
        expect(result).toEqual(
           [{
            flag: 0,
            min: 4
           }, 2]
        )
    })
})
describe("descParser.parseGlobalType", () => {
    let globalTypes = [0x7F , 0x7E , 0x7D , 0x7C, 0x70, 0x6f, 0x7B];
    for(let gt of globalTypes) {
        test(`parseglobaltype valtype ${gt.toString(16)} as val`, () => {
            const global = new Uint8Array([gt, 0x01]);
            let result = descParser.parseGlobalType(global, 0);
            expect(result).toEqual(
                [{
                    valtype: gt,
                    mutability: 1
                }, 2]
            )
        })
    }
    test("parseglobaltype invalid valtype", () => {
        const global = new Uint8Array([0x7A, 0x01]);
        expect(() => {
            descParser.parseGlobalType(global, 0);
        }).toThrowError(new Error("Invalid valType."))
    })

    test("parseglobaltype invalid mutability", () => {
        const global = new Uint8Array([0x7F, 0x03]);
        expect(() => {
            descParser.parseGlobalType(global, 0);
        }).toThrowError(new Error("Invalid mutability."))
    })
})

describe("parseExport", ()=>{
    test("parseExport section from arrays.wasm", ()=>{
        const exports = new Uint8Array([0x06, 0x05, 0x61, 0x72, 0x72, 0x61, 0x79, 0x00, 0x07, 0x03, 0x67, 
        0x65, 0x74, 0x00, 0x05, 0x06, 0x6C, 0x65, 0x6E, 0x67, 0x74, 0x68, 0x00, 0x02, 0x05, 0x72, 0x61, 
        0x6E, 0x67, 0x65, 0x00, 0x09, 0x06, 0x72, 0x65, 0x64, 0x75, 0x63, 0x65, 0x00, 0x0A, 0x06, 0x6D, 
        0x65, 0x6D, 0x6F, 0x72, 0x79, 0x02, 0x00, 0x0A, 0xA6, 0x02]); //last 3 are out of section, just for the sake of testing

        let result = bp.parseExport(exports, 0);
        // console.log(result);
        // expect(result).toEqual(
            
        // )
    })

})

describe("parseExpression", () =>{
    test("parsing a simple expression from arrays.wasm", ()=>{
        const expr = new Uint8Array([0x0D, 0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x03, 0x20, 0x02, 0x36, 0x02, 0x00, 0x0B, 0x54, 0x36]);
        const res = descParser.parseExpr(expr, 0, 0);
        expect(res).toEqual(
            [[
                13,  0, 32, 0, 32, 1,
                16,  3, 32, 2, 54, 2,
                0, 11
            ], 14]
        )
    })
})

describe("parseCode", () =>{
    test("code section from arrays.wasm", ()=>{
        const code = new Uint8Array([
            0x0A, 0x25, 0x01, 0x01, 0x7F, 0x41, 0x00, 0x28, 0x02, 0x00, 0x21, 0x01, 0x20, 0x01, 0x20, 0x00, 
            0x36, 0x02, 0x00, 0x20, 0x00, 0x41, 0x04, 0x6C, 0x20, 0x01, 0x6A, 0x41, 0x04, 0x6A, 0x41, 0x00, 
            0x36, 0x02, 0x00, 0x20, 0x01, 0x0F, 0x0B, 0x08, 0x00, 0x20, 0x00, 0x28, 0x02, 0x00, 0x0F, 0x0B, 
            0x0E, 0x00, 0x20, 0x01, 0x41, 0x04, 0x6C, 0x20, 0x00, 0x41, 0x04, 0x6A, 0x6A, 0x0F, 0x0B, 0x0D, 
            0x00, 0x20, 0x00, 0x20, 0x01, 0x10, 0x03, 0x20, 0x02, 0x36, 0x02, 0x00, 0x0B, 0x0C, 0x00, 0x20, 
            0x00, 0x20, 0x01, 0x10, 0x03, 0x28, 0x02, 0x00, 0x0F, 0x0B, 0x38, 0x01, 0x01, 0x7F, 0x41, 0x00, 
            0x41, 0x04, 0x36, 0x02, 0x00, 0x41, 0x04, 0x10, 0x01, 0x21, 0x04, 0x20, 0x04, 0x41, 0x00, 0x20, 
            0x00, 0x10, 0x04, 0x20, 0x04, 0x41, 0x01, 0x20, 0x01, 0x10, 0x04, 0x20, 0x04, 0x41, 0x02, 0x20, 
            0x02, 0x10, 0x04, 0x20, 0x04, 0x41, 0x03, 0x20, 0x03, 0x10, 0x04, 0x20, 0x04, 0x41, 0x02, 0x10, 
            0x05, 0x0F, 0x0B, 0x14, 0x01, 0x01, 0x7F, 0x41, 0x00, 0x41, 0x04, 0x36, 0x02, 0x00, 0x20, 0x00, 
            0x10, 0x01, 0x21, 0x01, 0x20, 0x01, 0x0F, 0x0B, 0x25, 0x00, 0x20, 0x00, 0x20, 0x01, 0x4B, 0x04, 
            0x40, 0x20, 0x03, 0x0F, 0x0B, 0x20, 0x03, 0x20, 0x02, 0x20, 0x00, 0x10, 0x04, 0x20, 0x00, 0x41,
            0x01, 0x6A, 0x20, 0x01, 0x20, 0x02, 0x41, 0x01, 0x6A, 0x20, 0x03, 0x10, 0x08, 0x0B, 0x21, 0x01, 
            0x02, 0x7F, 0x20, 0x01, 0x20, 0x00, 0x6B, 0x41, 0x01, 0x6A, 0x21, 0x02, 0x20, 0x02, 0x10, 0x07, 
            0x21, 0x03, 0x20, 0x00, 0x20, 0x01, 0x41, 0x00, 0x20, 0x03, 0x10, 0x08, 0x20, 0x03, 0x0F, 0x0B, 
            0x35, 0x01, 0x03, 0x7F, 0x20, 0x00, 0x10, 0x02, 0x21, 0x04, 0x41, 0x00, 0x21, 0x03, 0x20, 0x01, 
            0x21, 0x02, 0x03, 0x40, 0x20, 0x03, 0x20, 0x04, 0x49, 0x04, 0x40, 0x20, 0x00, 0x20, 0x03, 0x10, 
            0x05, 0x20, 0x02, 0x10, 0x00, 0x21, 0x02, 0x20, 0x03, 0x41, 0x01, 0x6A, 0x21, 0x03, 0x0C, 0x01, 
            0x0B, 0x0B, 0x20, 0x02, 0x0F, 0x0B
        ]);
        const res = bp.parseCode(code, 0);

        console.log(JSON.stringify(res, null, " "));
    })
})

describe("Full parse", () =>{
    test.skip("parsing the entire arrays.wasm", ()=>{
        const input = new Uint8Array(fs.readFileSync('../wasm/arrays.wasm'));
        console.log(JSON.stringify(parseModule(input), null, 2));
    })
    test("parsing the entire start.wasm", ()=>{
        const input = new Uint8Array(fs.readFileSync('../wasm/start.wasm'));
        console.log(JSON.stringify(parseModule(input), null, 2));
    })
})
describe("Name", () =>{
    test("parseName helper function", ()=>{
        const name = new Uint8Array([
            0x13, 0x69, 0x6D, 0x70, 0x6F, 0x72, 0x74, 0x73, 0x2F, 0x72, 0x65, 0x64, 0x75, 0x63, 0x65, 0x5F, 
            0x66, 0x75, 0x6E, 0x63
        ]);
        const res = descParser.parseName(name, 0);
        console.log(res)
    })
})
// console.log(Array.prototype.slice.call(test).map(byte=>byte.toString(16)))

// const dv:DataView = new DataView(test);
// console.log(dv)